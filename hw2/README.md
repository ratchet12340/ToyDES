# Needham-Schroeder/Diffie-Hellman Implementation
Below you will find instructions/implementation details for the hw2 practical implementation (programming) part.

# Getting started
Follow the steps below, _in order_:
1. `cd` into your cloned repo, specifically the `hw2/hw2_program` folder.
2. Run the KDC with `python3 kdc.py`
3. Run the first user `python3 alice.py some_message_to_send_to_bob`
4. Run the second user `python3 bob.py`
5. Done!
By now, you should have sent `some_message_to_send_to_bob` from one client to another.

# General Notes
As a rule of thumb, a lot of the numbers that are generated during the program's execution
are small, and therefore probably not secure. However, considering this was a "toy" implementation
of DES and key exchange algorithms, I assumed this would be permissible.

# Diffie-Hellman
My DH implementation follows the standard DH implementation:
1. The server and a client agree on a modulus and a base.
2. The client and server generate secret numbers a and b, respectively. Then, they form A=base^a mod modulus and B=base^b mod modulus, respectively.
3. The client and server compute the secret key(the initial shared key used in Needham-Schroeder) via key=B^a mod modulus and key=A^b mod modulus, respectively.
4. The program is now setup for the Needham-Schroeder key exchange.

# Needham-Schroeder
My NS implementation also follows the standard. However, the last two steps(one client showing the other that they have the key) was omitted. Again, as this was a toy implementation with 2 static clients, I did not find a reason to implement these steps. Since the KDC now has symmetric keys that are only known between KDC server and each client through the DH process, the NS process is straightforward.

Now comes the discussion of the prevention of replay attacks. While one can use a timestamp to prevent such attacks, I chose to use a nonce generated by Bob. Bob sends this to Alice before the NS process begins. The NS process continues as normal, but once Alice gives Bob his session key, encrypted under the symmetric key shared between the KDC and Bob, she also gives the nonce generated by Bob. Bob can verify that this nonce was the one he generated at the start. Through this nonce, an attacker would not be able to forge the nonce since the attacker does not have Bob and the KDC's shared symmetric key. Thus, the replay attack is prevented. My program includes a print statement if the nonces do, in fact, match from the one generated at the start to the one returned to Bob at the end.
